<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			#debug {
				position: absolute;
				top: 3em;
				width: 100%;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
				font-weight: bold;
			}
			#up {
				position: absolute;
				top: 50px;
                                right: 50px;
				width: 1em;
				padding: 1em;
				font-family: Monospace;
				font-size: 5em;
				text-align: center;
				font-weight: bold;
			}
			#down {
				position: absolute;
				top: 150px;
                                right: 50px;
				width: 1em;
				padding: 1em;
				font-family: Monospace;
				font-size: 5em;
				text-align: center;
				font-weight: bold;
			}


			a {
				color: #fff;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info"></div>
		<div id="debug"></div>
		<div id="up">+</div>
		<div id="down">-</div>

		<script src="../build/three.min.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="d3.341.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">



			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 200.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );

				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

				if ( gl_FragColor.a < ALPHATEST ) discard;

			}

		</script>


		<script>

// Get Star Database configuration file
var request = new XMLHttpRequest();
request.open('GET', 'HYG/hygdata_v3.csv', false);
request.send();
var starrows = d3.csv.parse(request.responseText);
starrows.shift();
var starhash = {};
starrows.forEach(function(star) {
    if (star["hr"]) {
        starhash["HR "+star["hr"]] = star;
    }
});
var stars = starrows.map(function(star) {
    star.pname = star.proper;
    star.vmag = star.mag;
    star.name = star.hr;
    return star;
});
function debug(str) {
    document.getElementById("debug").innerHTML = str;
}
// send our star selection somewhere
function report(star) {
    document.getElementById("info").innerHTML = star.spect;
    var msg = {"queue":[[ "127.0.0.1", "/star", 
                          "s",star.hr, 
                          "f",star.ra,
                          "f",star.dec, 
                          "f",star.dist, 
                          "f",star.mag, 
                          "s",star.spect,
                          "f",star.lum ]]};
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
        if (xhr.readyState==4) {
            try {
                if (xhr.status==200) {
                    var text = xhr.responseText;
                }
            } 
            catch(e) {
                alert('Error: ' + e.name);
            }
        }
    };
    xhr.open("POST","http://"+window.location.host+"/osc");
    xhr.overrideMimeType("application/json");
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.send( JSON.stringify( msg ) );
}
var nparticles = stars.length;
var starColours = {
  "O5":"#9db4ff",
  "B1":"#a2b9ff",
  "B3":"#a7bcff",
  "B5":"#aabfff",
  "B8":"#afc3ff",
  "A1":"#baccff",
  "A3":"#c0d1ff",
  "A5":"#cad8ff",
  "F0":"#e4e8ff",
  "F2":"#edeeff",
  "F5":"#fbf8ff",
  "F8":"#fff9f9",
  "G2":"#fff5ec",
  "G5":"#fff4e8",
  "G8":"#fff1df",
  "K0":"#ffebd1",
  "K4":"#ffd7ae",
  "K7":"#ffc690",
  "M2":"#ffbe7f",
  "M4":"#ffbb7b",
  "M6":"#ffbb7b",
  "O":"#9bb0ff",  
  "B":"#aabfff",  
  "A":"#cad7ff",  
  "F":"#f8f7ff",  
  "G":"#fff4ea",  
  "K":"#ffd2a1",  
  "M":"#ffcc6f"  
};
function starColour(spect) {
    return starColours[spect.substring(0,2)] || starColours[spect[0]] || "#FFFFFF";
};
function hexColour2RGB(hex) {
    return [
        parseInt(hex.substring(1,3),16),
        parseInt(hex.substring(3,5),16),
        parseInt(hex.substring(4,6),16)
    ];       
}
function starColourRGB(spect) {
    return hexColour2RGB(starColour(spect));
}
function starSize(star) {
    return 1.0 +  Math.pow(1.5, -star.vmag);
}

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
                        var recent = {};
			var renderer, scene, camera, stats;

			var particles, uniforms, attributes;

			var PARTICLE_SIZE = 20;

			var raycaster, intersects;
			var mouse, INTERSECTED;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200000 );
			        //camera.position.set(new THREE.Vector3(0,0,0.5));
                                camera.position.z = 2;
                                camera.lookAt(new THREE.Vector3( 0, 0, 10000 ));

                                document.getElementById("up").onclick = function() {
                                    camera.position.z+=10;
                                };
                                document.getElementById("down").onclick = function() {
                                    camera.position.z-=10;
                                };


				//

				attributes = {

					size:        { type: 'f', value: [] },
					customColor: { type: 'c', value: [] }

				};

				uniforms = {

					color:   { type: "c", value: new THREE.Color( 0xffffff ) },
					texture: { type: "t", value: THREE.ImageUtils.loadTexture( "textures/sprites/disc.png" ) }

				};

				var shaderMaterial = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					attributes: attributes,
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					alphaTest: 0.001,

				} );

			    geometry = new THREE.BufferGeometry();
			    var positions = new Float32Array( nparticles * 3 );
			    var values_color = new Float32Array( nparticles * 3 );
			    var values_size = new Float32Array( nparticles );


			var color = new THREE.Color();
                        var radius = 1000;
			for( var v = 0; v < nparticles; v++ ) {

				values_size[ v ] = 1.0;//starSize(stars[v]);

				positions[ v * 3 + 0 ] = stars[v].x;//( Math.random() * 2 - 1 ) * radius;
				positions[ v * 3 + 1 ] = stars[v].y;//( Math.random() * 2 - 1 ) * radius;
				positions[ v * 3 + 2 ] = stars[v].z;//( Math.random() * 2 - 1 ) * radius;

				color.setHSL( v / nparticles, 1.0, 0.5 );
                                var c = starColourRGB( stars[v].spect );
				values_color[ v * 3 + 0 ] = c[0]/255;
				values_color[ v * 3 + 1 ] = c[1]/255;
				values_color[ v * 3 + 2 ] = c[2]/255;

			}
			attributes.size.value = values_size;

			geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
			geometry.addAttribute( 'customColor', new THREE.BufferAttribute( values_color, 3 ) );
			geometry.addAttribute( 'size', new THREE.BufferAttribute( values_size, 1 ) );


			//var geometry = new THREE.BoxGeometry( 200, 200, 200, 16, 16, 16 );
                            
		        particles = new THREE.PointCloud( geometry, shaderMaterial );



			    scene.add( particles );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2()

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}
			function render() {
                            
			    //particles.rotation.x += 0.0005;
			    particles.rotation.y += 0.0001;

				raycaster.setFromCamera( mouse, camera );

				intersects = raycaster.intersectObject( particles );
                                //debug(JSON.stringify(intersects.map(function(x){return x.index})));
                            
				if ( intersects.length > 0 ) {
                                    var d = new Date();
                                    var m = d.getTime(); 
                                    for (var i = 0 ; i < intersects.length; i++) {
                                        var index = intersects[i].index;
                                        var star = stars[index];
                                        var diff = m - (0||recent[index]||0);
                                        //debug(diff);
                                        if (diff > 100) {
                                            report(star);
                                            recent[index] = m;
                                            break;
                                        }
                                        recent[index] = m;                                        
                                    }
                                    /*
					if ( INTERSECTED != intersects[ 0 ].index ) {
                                            
					        attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE;

						INTERSECTED = intersects[ 0 ].index;

						attributes.size.value[ INTERSECTED ] = PARTICLE_SIZE * 1.25;
						attributes.size.needsUpdate = true;

					}*/
				} else if ( INTERSECTED !== null ) {
                                    /*
                                        var star = stars[INTERSECTED];
					attributes.size.value[ INTERSECTED ] = starSize(star);
					attributes.size.needsUpdate = true;
					INTERSECTED = null;
                                    */
				}

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>
